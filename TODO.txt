== COURT TERME ==

~ Faire le doomlike (partie 1)
	-> Faire un système de GameplayStatics pour pouvoir récupérer la référence au Game et à la Scene - fait
	-> Faire la base de l'ennemi (mesh, raycast vers le joueur, orientation, réaction aux balles) - fait
	-> Mettre les meshs d'arme et de balles - fait
	-> Intégrer la mort du joueur - fait
	-> Récupérer des meshs/textures pour un décor - fait
	-> Faire un système pour faire réagir une partie du niveau en fonction des ennemis tués - fait
	-> Faire un premier niveau simpliste - fait
	-> Améliorer l'ennemi avec le déplacement vers le joueur - fait
	-> Faire le système de trigger qui ferait réagir des parties du niveau (lumière, objets...) et changement de niveau - fait
	-> Mettre un espèce de camera lag pour que les escaliers ça soit moins horrible - fait
	-> Mettre les balles en emissive pour mieux les voir - fait
	-> Faire un bon niveau avec des salles et des éléments cinématiques sur les lumières et autres - fait
	-> Ajouter une distance max sur le camera lag - fait
	-> Vérifier que tout est nickel après le rework de la physique

~ Retour sur la physique : collide and slide (https://www.youtube.com/watch?v=YR6Q7dUz2uk)
	-> Faire un raycast sweep AABB - fait
	-> Faire la inversed step mechanic - fait
	-> Utiliser le raycast sweep AABB pour le collide and slide avec projection d'un vecteur sur une surface - en cours
	-> Regarder si le pb des plateformes mouvantes existe toujours et le fix
	-> Rajouter des vraies trigger box


== MOYEN TERME ==

~ Mettre le renderer en classe statique et donner l'accès aux classes statiques avec le pattern Service Locator
	https://drive.google.com/file/d/1W174x3x0xS9eDg1xIUMdzxdSxznol8Zu/view?usp=drive_link page 285

~ Intégrer du son (avec fmod ?)

~ Créer un système de HUD (intégrer le texte tout de suite ?)

~ Faire une classe debug qui permet de gérer les logs dans la console et sur l'écran (à la manière d'unreal)

~ Utiliser le système d'event pour les fonctionnalités importantes du moteur (pause, etc.)


== LONG TERME ==

~ Intégrer l'ECS (pas FLECS pour l'instant, mais un système assez simple qui permettrait au moins de mieux gérer les collisions, les meshs, etc.)

~ Améliorer le système de lumière

~ Faire le système des ombres

~ Animations 3D : https://ogldev.org/www/tutorial38/tutorial38.html

~ "Finir" la physique avec la répulsion des collisions body/body (imagine pousser une caisse dans un mur oskour)


== TRES LONG TERME == (aka ça sera jamais fait)

~ Mettre des particules

~ Mettre un système de physique supportant plus que du AABB

~ Mettre un editeur :skull:


== CORRECTIONS DE PROBLEMES ==

~ Utiliser les infos dans les meshs pour sortir les IDs des materiaux et permettre une assignation de materiaux plus poussée et plus simple

~ Mettre un système pour détecter automatiquement la profondeur de couleur au chargement de la texture pour éviter les problèmes (si la profondeur de couleur est 24, pas d'alpha (même avec un .png), donc charger avec GL_RGBA va faire un crash) -> regarder comment gregory a fait pour xenity


== REFLEXIONS / PROBLEMES CONNUS ==

~ Réfléchir au fonctionnement du load asset des scenes, est-ce qu'il faudrait faire gaffe à l'utilisation de ram et unload genre les textures qui ne sont plus nécessaires ?

~ Si l'épaisseur de la collision d'un plafond est faible, il est possible de passer à travers en sautant d'en dessous (à cause de la step mechanic ?), il faudrait trouver pourquoi ça fait ça et le corriger (vérifier si ça reste toujours après le changement avec le collide and slide)

~ Trouver une solution pour les problèmes de rotations avec la caméra (étudier unreal ? réussir à combiner la matrice de la caméra et celle du joueur ?)