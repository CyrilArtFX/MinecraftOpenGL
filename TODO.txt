== COURT TERME ==

~ Mettre un système de physique basique pour le doomlike (collisions cubes AABB, gravité, raycasts)
	-> mettre des box aabb - fait
	-> faire le système d'affichage debug et un visionnage des box - fait
	-> fixer les box a des objets pourvus de transform ? et tester le mouvement - fait
	-> faire de la détection point / aabb - fait
	-> faire des raycast qui répondent au aabb - fait
	-> faire un event qui s'apelle quand la box subit une collision - fait (cimer arthur)
	-> faire la detection de collision entre box aabb - fait
	-> intégrer la ccd - fait
	-> faire la répulsion entre box aabb (position pas rotation) pour les collisions body/static - fait
	-> changer le système de ccd pour utiliser la velocité du rigidbody - fait
	-> update la vélocité des rigidbody en fonction des collisions - fait
	-> changer le système de répulsion pour utiliser la normal de la collision - fait
	-> mettre la gravité et bien tester ça - fait
	-> améliorer la manière dont on peut programmer des mouvements pour pas avoir des trucs rigides comme actuellement - fait
	-> faire la detection ccd / ccd : https://blog.hamaluik.ca/posts/swept-aabb-collision-using-minkowski-difference/
	-> faire la répulsion entre box aabb (position pas rotation) pour les collisions body/body (je me chie dessus de peur)
	-> finir le setup du système physique (objects channels, etc.)
	-> épreuve ultime : faire bouger le joueur sur des plateformes mouvantes (pitié la physique)

KNOWN ISSUE : marcher entre deux collisions à la même hauteur (comme deux sols côte à côte) pose problème.
Ca serait bien même de faire en sorte de pouvoir marcher sans problème entre deux collisions avec une petite différence de hauteur


~ Faire le doomlike (omg ?)


== MOYEN TERME ==

~ Intégrer du son (avec fmod ?)

~ Créer un système de HUD (intégrer le texte tout de suite ?)

~ Faire une classe debug qui permet de gérer les logs dans la console et sur l'écran (à la manière d'unreal)

~ Utiliser le système d'event pour les fonctionnalités importantes du moteur (pause, etc.)

~ Améliorer le système de lumière

~ Faire le système des ombres

~ Mettre un vrai système de physique

~ Intégrer l'ECS (attendre le cours sur le multithreading dans un engine)


== REFLEXIONS ==

~ Mettre le renderer en classe statique ? permettrait d'assigner certains assets (comme les materiaux) directement à la création par exemple + de ne pas avoir à le passer en paramètre pour le joueur qui va devoir créer des balles (par exemple)

~ Mettre un système pour détecter automatiquement la profondeur de couleur au chargement de la texture pour éviter les problèmes (si la profondeur de couleur est 24, pas d'alpha (même avec un .png), donc charger avec GL_RGBA va faire un crash) -> regarder comment gregory a fait pour xenity

~ Réfléchir au fonctionnement du load asset des scenes, est-ce qu'il faudrait faire gaffe à l'utilisation de ram et unload genre les textures qui ne sont plus nécessaires ?

~ Les objets scenes sont créés avant que le loadDefaultAssets soit appelé par l'objet game ?

~ Trouver une solution pour les problèmes de rotations avec la caméra (étudier unreal ? réussir à combiner la matrice de la caméra et celle du joueur ?)

~ Essayer de comprendre pourquoi si les bullets sont pas stockées en unique_ptr ça fait complètement n'importe quoi (genre c'est abusé de fou)
Infos sur le problème :
 - même en créant la bullet dans la liste directement et en faisant le setup depuis là ça bug
 - si y'en a qu'une à la fois ça a l'air d'aller
 - c'est le iter_swap qui pose problème ?
 - avec le système que j'avais, ça supprimait la première balle (seulement visuellement mais aucune fonction de suppression n'était appelée) et quand je spammais ça crashait